'use strict';
import { TupleHelper, Tuple } from "./tuple";


export class Combination implements Iterable<Tuple> {
	private readonly _items: Tuple;
	private readonly _total: number;
	private readonly _size: number;
	private readonly _count: bigint;
	private _currentIndex: bigint;
	private _indices: number[];
	private _values: Tuple;


    /**
	 * Build a combination iterator
	 */	
    constructor(items: Tuple, size: number) {
        // super();
		if (size <= 0 || size > items.length) throw new Error("Invalid size value");
		
    	this._items = items;
    	this._total = items.length;
        this._size = size;
        this._count = TupleHelper.binomial(this._total, size);

    	this._indices = Array.from({ length: size }, (_, i) => i);
    	this._values  = Array.from({ length: size }, (_, i) => items[i]);
        this._currentIndex = 0n;
    }


	get total(): number { return this._total; }
	get size(): number { return this._size; }
	get count(): bigint { return this._count; }
	get lastIndex(): bigint { return this._count - 1n; }
	get currentIndex(): bigint { return this._currentIndex; }
	get currentTuple(): Tuple { return [...this._values]; }


	/**
	 * Gives the first tuple
	 * @param        none
	 * @return       first tuple
	 */
    public start(): Tuple {
    	this._currentIndex = 0n;
		for (let i = 0; i < this._size; i++) {
			this._indices[i] = i;
			this._values[i] = this._items[i];
		}
    	return [...this._values];
    }


    /**
	 * Gives the last tuple
	 * @param        none
	 * @return       last tuple
	 */
    public end(): Tuple {
		this._currentIndex = this.lastIndex;
		for (let i = 0; i < this._size; i++) {
			this._indices[i] = this._total - this._size + i;
			this._values[i] = this._items[this._indices[i]];
		}
		return [...this._values];
    }


	/**
	 * Resets the iterator to the first tuple and returns it.
	 */
	public reset(): Tuple {
		return this.start();
	}


	/**
	 * Gives the previous tuple or null if
	 * there is no more previous tuple
	 * @param        none
	 * @return       previous tuple
	 */
	public previous(): Tuple|null {
		if (this._currentIndex <= 0n) return null;
		this._currentIndex--;

		let i = this._size - 1;
		while (i >= 0) {
			const minAllowed = (i === 0) ? 0 : (this._indices[i - 1] + 1);
			if (this._indices[i] > minAllowed) break;
			i--;
		}
		if (i < 0) return null;

		this._indices[i]--;
		for (let j = i + 1; j < this._size; j++) { this._indices[j] = this._total - (this._size - j); }

		for (let j = 0; j < this._size; j++) { this._values[j] = this._items[this._indices[j]]; }
		return [...this._values];
	}


	/**
	 * Gives the next tuple or null if
	 * there is no more next tuple
	 * @param        none
	 * @return       next tuple
	 */
	public next(): Tuple|null {
		if (this._currentIndex >= this.lastIndex) return null;
		this._currentIndex++;

		let i = this._size - 1;
		while (i >= 0 && this._indices[i] === this._total - this._size + i) { i--; }
		if (i < 0) return null;

		this._indices[i]++;
		for (let j = i + 1; j < this._size; j++) { this._indices[j] = this._indices[j - 1] + 1; }

		for (let j = 0; j < this._size; j++) { this._values[j] = this._items[this._indices[j]]; }
		return [...this._values];
	}


	/**
	 * ES6 iterator over all tuples generated by this Combination object.
	 *
	 * Allows usage such as:
	 * ```ts
	 * for (const tuple of combination) {
	 *     // ...
	 * }
	 * ```
	 *
	 * The iteration starts at the first tuple (equivalent to calling {@link start})
	 * and continues until the last tuple (when {@link next} returns `null`).
	 */
	public [Symbol.iterator](): IterableIterator<Tuple> {
		let started = false;
		let done = false;
		const self = this;

		return {
			next(): IteratorResult<Tuple> {
				if (done) return { value: undefined, done: true };

				let value: Tuple | null;
				if (!started) {
					value = self.start();
					started = true;
				} else {
					value = self.next();
				}

				if (value === null) {
					done = true;
					return { value: undefined, done: true };
				}
				return { value, done: false };
			},

			[Symbol.iterator](): IterableIterator<Tuple> {
                return this;
            }
		} as IterableIterator<Tuple>;
	}
}

